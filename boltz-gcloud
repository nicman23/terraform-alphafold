#!/bin/bash

if [ -z "$STY" ]; then
  echo must be run from a \(GNU\) screen
  exit
fi

source $(dirname $(realpath $0))/command_center_lib.sh


get_additional_files() {
  (
  while read l ; do
    echo $l;  jq < $l | grep Path\": | rev | cut -f2 -d\" | rev | sed "s~^~./$input/~g";
  done 2>/dev/null
  )
}
send_work() {
  sssh rm -rf $output $input workdir work_done final_done &>/dev/null
  pv $work_zstd | sssh 'zstd -d | tar -xf -'
  ls af_output/ |
   sssh 'while read dir; mkdir -p $dir'
  cat << EOF | sssh cat - \> work.sh
  rm -rf $output workdir
  mkdir $output workdir
  cd $input
  rm /root/work_done /root/final_done
  for i in *json; do
    mkdir -p /root/workdir/\$i
    cp /root/$input/\$i /root/workdir/\$i/
    [ -e /root/$output/\$i ] && continue
    boltz predict ${input}/\$i --out_dir /root/workdir/\$i --use_potentials
    mv /root/workdir/\$i /root/$output/
    echo \$i >> /root/work_done

  done
  touch /root/final_done
EOF
}

input=$1
output=boltz_outputs_${input}
template=boltz-aws-L40S
cloud=aws

if ! ls $input/*json &>/dev/null; then
  echo $input empty
exit 2
fi
mkdir -p $output

get_files() {
  ls $input $output | grep -v msa_output | grep json | sort | uniq -u |
    while read l; do
      [ -e $input/$l ] && echo $input/$l
    done
}

files=( $(get_files) )
files_m=$(( ${#files[@]} -1 ))
max_vms=4
step=$(( files_m / max_vms ))
files_i=0
name_prefix=$(basename $(realpath .) |  tr '[:upper:]' '[:lower:]')

created_vms=()

trap cleanup EXIT
trap cleanup ERR

echo refreshing state please wait
wait_for_lock
refresh_state

main_af &

fancy

wait