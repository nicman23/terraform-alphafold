#!/bin/bash

source $(dirname $(realpath $0))/lib.sh
if [ -z "$STY" ]; then
  echo must be run from a \(GNU\) screen
#  exit
fi

bash /home/gcloudPuppet/terraform-alphafold/auth.sh

create_and_send () {
  name="vm-$(uuidgen)"
  create_vm a100-af echo
  ip=$(get_ip_from_name)

(
  af_do_work $1

  delete_vm
) &
}

af_do_work() {
  while ! sssh $ip true; do
    sleep 2
  done

  pv $1 | sssh $ip 'zstd -d | tar -xf -'

  cat << EOF | sssh $ip cat - \> work.sh
  ln -fs /root/mlibs /root/public_databases
  mkdir af_output workdir
  cd af_input
  rm /root/work_done /root/final_done
  for i in *json; do
    mkdir -p /root/workdir/\$i
    [ -e /root/af_output/\$i ] && continue
    docker run --name main -d  \
      --volume /root/:/root/ \
      --gpus=all \
      alphafold3 \
      python run_alphafold.py \
      --json_path=/root/af_input/\$i \
      --model_dir=/root/models \
      --output_dir=/root/workdir/\$i
    docker wait main
    docker logs main > /root/workdir/\$i/log
    docker rm main
    mv /root/workdir/\$i /root/af_output/
    echo \$i >> /root/work_done

  done
  touch /root/final_done
EOF

### fetcher thread ###
(
  sleep 1m
  while ! sssh $ip cat final_done; do
    sleep 10m
    ip=$(get_ip_from_name)

    if sssh $ip cat work_done; then
      buf="$(sssh $ip cat work_done)"
      for l in $buf; do
        mkdir -p af_output/workdir/
        srsync -r $ip:/root/af_output/$l af_output/workdir/$l
      	mv af_output/workdir/$l af_output/$l
      done
      sssh $ip rm work_done
    fi
  done
#  srsync -r $ip:/root/af_output/ af_output/
  touch af_output/final_done
)  &>> out.rsync &

  while ! sssh $ip cat final_done; do
    sssh $ip 'bash work.sh' ||
    check_health
  done
  wait
}

get_msa_too() {
  (
  set +e
  while read l ; do
    echo $l;  jq < $l | grep Path\": | rev | cut -f2 -d\" | rev | sed 's~^~./af_input/~g';
  done 2>/dev/null
  )
}

set -eE
if ! ls af_input/*json; then
echo af_input empty
exit 2
fi
mkdir -p af_output

#pubkey=$(cat $(ls ~/.ssh/*pub | head -n1) )

already_done=( $(cd af_output ; ls | sed 's~^~af_input/~g') )
files=( $(find af_input -name \*json | while read l; do [[  "${already_done[@]}" =~ "$l"  ]] || echo $l; done) )
files_m=$(( ${#files[@]} -1 ))
max_vms=4
max_vms=$((max_vms -1 ))
step=$(( files_m / max_vms ))
files_i=0

#tmpfiles=( $PWD/af_output/workdir/ )
tmpfiles=()


cleanup() {
  rm -rf ${tmpfiles[@]} af_output/workdir/
  delete_vm $LAST_VM
}

#trap cleanup EXIT
#trap cleanup ERR

while [ $files_m -ge $files_i ] ; do
  t_d=$(mktemp -dp .)
  for i in `seq $files_i $(( step + files_i ))`; do
    echo ${files[$i]}
  done | get_msa_too > $t_d/part.txt
  files_i=$(( files_i + step + 1 ))

  tar -cf - -T $t_d/part.txt |
  zstd -1 > $t_d/af_input.tar.zst
  rm $t_d/part.txt
  tmpfiles+=($PWD/$t_d/)
done

for tmpfile in ${tmpfiles[@]}; do
  create_and_send $tmpfile/*tar.zst
done

#delete_vm $LAST_VM

wait
